# Missouri EPSCoR Computer Science Institute for Women

This csiw_2015 branch contains the materials from the CSIW 2015 workshop.

## Funding
Raspberry Pi Foundation  
National Science Foundation  
Missouri EPSCoR  

# Table of Conents
* [Day 1](#day-1)
* [Day 2](#day-2)
* [Day 3](#day-3)

#Day 1  
*  [Introduction to Raspberry Pi Computers](#introduction-to-raspberry-pi)
*  [Introduction to Github and collaborative coding](#introduction-to-github-and-linux)
*  [More with Linux](#basic-linux-shell-commands)
*  [Using the Raspberry Pi camera](#using-the-raspberry-pi-camera)
*  Insights into Computer Science: Abby Stylianou
*  Introduction to rePhoto
*  Tour of the Danforth Center and Maker technologies

## Introduction to Raspberry Pi

*  See these websites for more information on how to use Raspberry Pis:
    *  [https://www.raspberrypi.org/](https://www.raspberrypi.org/)
    *  [http://sonic-pi.net/](http://sonic-pi.net/)
    *  [https://learn.adafruit.com/category/raspberry-pi](https://learn.adafruit.com/category/raspberry-pi)
    *  [http://www.raspberrypitutorials.yolasite.com/](http://www.raspberrypitutorials.yolasite.com/)  

*  Other useful websites:
  *  Thingiverse has lots of patterns to 3D print [here](https://www.thingiverse.com/)
  *  Raspberry Pis are computers but Arduino microcontrollers are also very useful for projects [here](https://www.arduino.cc/)
  *  OpenScad is a free program to design 3D objects [here](http://www.openscad.org/)
  *  More info on Github pages [here](https://pages.github.com/)
  *  Jekyll is a tool to help develop your website with Github [here](https://help.github.com/articles/using-jekyll-with-pages/)

### Raspberry Pi Command line vs. GUI

In addition to the command-line interface, Raspberry Pi computers can run a desktop environment (graphical user interface, or GUI). To start it type after logging in:

```
startx
```
##Introduction to Github and Linux

**[Github](https://github.com/): Github is a way to code collaboratively, or to find code to jumpstart your project. Github + Jekyll + Markdown is also an easy way to set up a website for your projects. All of our workshop materials are available on Github, this allow us to make updates as we go along and to make the materials available to you later on**

**What is Linux?: Linux is an operating system, which is software that supports basic computer functions.
Other examples of operating systems are Unix, Mac OS, Windows XP or Windows 7. You can do things like,
make files, move files, copy files, make directories (folders) etc. etc. but instead of seeing icons like a Windows or Mac interface you would use text (the command line).**

From the desktop you can run a terminal program to continue to use the command-line interface (called LXTerminal).

To clone a basic repository in LXterminal type:

```
git clone "copied repository link"

```

**To clone our workshop materials (6 Steps)**

Step 1:  

```Python
# List your current location (you want know where you are putting the workshop materials)

pwd
```
Step 2:

```
# List the files in your current location

ls -l
```
Step 3:

```
# Make a folder for the workshop materials

mkdir csiw_2015
```
Step 6:

```
# See the new folder you just made

ls -l

```

Step 5:

```
# Move to the folder you just made

cd /home/pi/csiw_2015
```

Step 6: 

```
# clone the outreach materials from github into your new folder

git clone https://github.com/danforthcenter/outreach.git --branch csiw_2015 

```  

### Getting Updated Materials from Github

**We might update materials as the workshop goes on. To update the materials on your computer there are 2 steps**

Step 1.

```
# Make sure you are in your github folder

cd /home/pi/csiw_2015/outreach/

```

Step 2.

```
# Pull the new information from github

git pull

```

##Basic Linux shell commands  

If you need help on how/why to use a command the best thing to do is to google it.  

**pwd** - print the current working directory path. The "working directory" means the folder you are currently in.  

**ls** - list the files and directories in the current working directory

**cd** - change directories directly to *home*

**cd** ***dir*** - change directories from the current working directory to *dir*

**touch** ***file*** - create the empty file *file*

**rm** ***file*** - remove the file *file*

**mkdir** ***dir*** - make the directory *dir*

**rmdir** ***dir*** - remove the directory *dir* (has to be empty)

**cp** ***file1*** ***file2*** - create a copy of *file1* called *file2*

**cp -r** ***dir1*** ***dir2*** - create a copy of *dir1* and its contents called *dir2*

**mv** ***file1*** ***file2*** - move/rename *file1* to *file2*

**head** ***file*** - print the first 10 lines of *file* to *stdout*

**tail** ***file*** - print the last 10 lines of *file* to *stdout*

**less** ***file*** - opens *file* using a paging viewer

**htop** - display the current running processes (task manager/activity monitor). It is a modern version of **top** which should be available if **htop** is not.

**df -h** - display disk usage with human-readable units

**gzip** ***file*** - compress *file*

**gunzip** ***file.gz*** - decompress *file.gz*

**tar zcf** ***archive.tar.gz*** ***dir*** - create a compressed archive of *dir* (or a set of files)

**tar zxf** ***archive.tar.gz*** - decompress and extract the contents of *archive.tar.gz*

**Ctrl+C** - stop the current command

**exit** - log out of the current session

**sudo** ***command*** - execute *command* with administrator privileges

**apt-get install** ***program*** - apt-get is the Debian Linux package manager. You can use it to install new software on your computer

**apt-get update** - update the installed packages on your system 

##Using the Raspberry Pi camera

The Raspberry Pi camera module is a 5 megapixel, fixed-focus camera add-on for the Raspberry Pi. Each of your Raspberry Pi computers has a camera module installed. Your camera module is the Pi NoIR model (the infrared filter has been removed).

### Take a picture

To take a picture, see it, and save it with the name *image.jpg* use the following command:

```python

# This command will take a picture but it will put it in whatever
# working directory (folder) you are in.

# The -o is an option/flag that tells the program what we want to
# name the image and also where to put it. If it is just the name
# it puts the image in whatever folder you are currently in.

raspistill -o image1.jpg

# To see where you've save the image
# (what folder you are currently in) type:

pwd

# To see the names of the files in your current folder type

ls -l

```

**Pro-tip, if you want to rerun a command that you recently used, you can hit the uparrow to get to previous commands**

To actually view the image, you can go to the file folder icon on the desktop and open the file or on the command line...

```

display /home/pi/images/image1.jpg

```

###Flip a picture if it is upside down

Is your picture upsidedown when you look at it? If it is you will need to add the -vf (vertical flip) flag to your command.

```

raspistill -vf -o image1.jpg

```

### Save images with unique names and some metadata
If you add the current date and time to the name of your images you can use the same command over and over again because each image will have a unique name and doesn't get overwritten.


To take a picture, see it, and save it with the date and time in front of the name image.jpg in the directory images in your home folder use the following command: 

```
# the name of the image below would include the current year,
month, day, hour, minute, and second

raspistill -o /home/pi/images/$(date +"%Y-%m-%d_%H:%M:%S")_images.jpg

# now press the up arrow, the command you just ran
should show up, take another picture.
```

### Take a time-lapse

After you take a few pictures and are satisfied with the setup you can take a time-lapse

```
# to take a timelapse you need to use the -tl option, which is the time between images, but the time is in milliseconds
# you also need the -t option, which tells the program how long to run timelapse
# the command below takes an image named using the timestamp every 3 seconds for 1 min
# We cannot use the timestamp to name the images because how the program is written, but we can use another way of naming the images
# by nameing the images image%05d.jpg we tell the program to give the image a 5 digit number at the end of the name
# So the first image would be named image00001.jpg

raspistill -t 60000 -tl 3000 -o /home/pi/images/image%05d.jpg 

```

### What happens if the computer shuts off during the time-lapse?  

In order to make sure that the computer will keep running the time-lapse if the computer shuts off you need to modify
crontab.

### Use cron to take images on a schedule (time-lapse)

Crontab is an easy way to schedule repeating tasks so it can be used as another way to do time-lapse imaging, like time-lapse imaging.  

Now make a folder called timelapse and open crontab in a text editor

```
mkdir /home/pi/timelapse
```

Open up the crontab file using the leafpad text editor program. We need to have administrator privilege to modify this file.

```
sudo leafpad /etc/crontab

Crontab file format:
# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user command to be executed
```

Add the following line to the cron file (you should see a list of commands that also start with an astericks).

```
#this tells the command to run every 10 min of every hour every day of the month every day of the week.

*/1 * * * * pi /usr/bin/raspistill -o /home/pi/timelapse2/$(date +"\%Y-\%m-\%d_\%H:\%M:\%S")_timelapse.jpg

#save the file and close it

```

Now we need to restart the cron service to make sure the changes take effect. On the command line type

```
sudo service cron restart

```

* Can I test my commands before putting them into crontab?  
  *  Yes! Just run them on the command line first in the terminal!!!!
* Why use crontab?
  *  It will automatically run task as scheduled, even after reboot!

**Note:** Time is set after booting and internet access, but if no internet, it will set time to last available time, which can cause problems. Hope you have wifi!!!! Alt: can hardwire a clock with battery.


### Assembling your time-lapse into a short movie

first we need to write all of image names into a text file, but we can do that using the command line  

```

# This takes all of jpg files in your current folder and writes their names to a file called stills.txt 

cd /home/pi/timelapse/

ls *.jpg > stills.txt

```  

now we can assemble the files into a time-lapse movie  


```
# -ocv tells the mencoder program what video format to use  
# -lavcopts tells the opctions you want for the video format (size etc.)
# -o tell the program what to name your file
# -mf tells the program what file format and the number of frames per second that you want, as well as the file with all the image names

mencoder -nosound -ovc lavc -lavcopts vcodec=mpeg4:aspect=16/9:vbitrate=8000000 -vf scale=1920:1080 -o timelapse.avi -mf type=jpeg:fps=24 mf://@stills.txt

#if you need to flip your images
mencoder -nosound -ovc lavc -lavcopts vcodec=mpeg4:aspect=16/9:vbitrate=8000000 -vf scale=1920:1080 -flip -o timelapse.avi -mf type=jpeg:fps=24 mf://@stills.txt

```

```
# To play your video use the program omxplayer

omxplayer timelapse.avi

```


###Now let's move your movie to a folder with your name

```

#let's make a directory (folder) with your name (no spaces)

mkdir /home/pi/yourname

#for example: mkdir /home/pi/malia

# then let's list the files to see if your folder is there

ls -l /home/pi/

# you should see a folder with your name

#now let's move your timelapse.mp4 movie there, make sure you replace the "yourname" with your actual name

mv /home/pi/images/timelapse2/timelapse.mp4 /home/pi/yourname/timelapse.mp4

#check that the file is in there

ls -l /home/pi/yourname/

```
###Opensource tools for image analysis

Collecting time lapse images are great for demonstrating concepts of plant growth, plant movement, and circadian rhythms.
But you might want to actually measure plant growth and plant movement. There are several opensource tools that make these measurements easier.

*  ImageJ is [here](http://fiji.sc/Fiji)
*  OpenCV (Open Computer Vision) is a library of image processing functions for a few languages (C/C++, Java, Python) that is widely used.  
There is documentation [here](http://opencv.org/). OpenCV is a very powerful library but it is not the most user friendly.
We built PlantCV (Plant Computer Vision) to process plant images specifically, building off of OpenCV and other available Python libraries.  
*  PlantCV documentation and information is located [here](http://plantcv.danforthcenter.org/)
*  R is a programming language that is used for statistical analysis, more information [here](http://www.r-project.org/)
*  R studio is a free graphical user interface (GUI) to make running R code easier. More info [here](https://www.rstudio.com/)

####Process images with ImageJ

[ImageJ](imagej.nih.gov/ij/) is a free image quantification software developed by the National Institutes of Health (NIH). Go [here](http://imagej.nih.gov/ij/docs/guide/index.html) for detailed instructions.

Install imageJ on your Raspberry Pi using the following commands:  

```
sudo apt-get update	
```  

```
sudo apt-get install imageJ
```
After installation, imageJ will be installed in the Menu-->Graphics tab

Open imageJ, and open a file (This can be any image, or the ImageJ/sample_image_ruler.jpg')

An example of how to measure length and angles can be found [here](https://www.youtube.com/watch?v=8IrTXUDqmXI)

To measure length:  
1. Use the line tool to draw a known length (use 1 cm in example)  
2. Select Analyze--> Measure  
3. Select Analyze--> Set Scale  
4. Set known distance to 1, unit of length to cm  
5. Draw line over stem in picture  
6. Select Analyze--> Measure  

####Process images with PlantCV

[PlantCV](http://plantcv.danforthcenter.org/) is software we wrote at the Danforth Center to extract biologically meaningful information from images of plants. Go to [here](http://plantcv.danforthcenter.org/pages/documentation/function_docs/vis_tutorial.html) for detailed instructions.

Pick an image and look at the name to determine which script to run most scripts are in dev (see example below) type:

```
path_to_script -i path_to_image -o destination_folder_for_output_images -D
```

For example:

```python

#The first part is the script that is being run.
#The -i is the path to the image you want analyzed
#The -o tells the program where to put the output images. A . means it will put the images in whatever directory you are currently in.
#The -D option at the end tells the program you are running it in debug mode, this means that every image at every step will get printed out (there are lots of steps, so lots of images)

/home/pi/plantcv/scripts/dev/vis_sv_z2500_L2_e82.py -i /home/pi/nsf_reu_workshop/sample_images/brachypodium/VIS_SV_0_z2500_h2_g0_e82_300296\ copy.png -o . -D

```

You just processed one image, you will see a bunch of information print out to the screen, and lots of new images appear in your working directory.
If you had many images to process you would then use the "parallelization" script, which runs the 'single image script' over a bunch of images and
then saves the data to a database. We won't be doing that today but the instructions are [here](http://plantcv.danforthcenter.org/pages/documentation/function_docs/vis_tutorial.html).
If you had run a full set of data (many plants growing over a period of time) you could then use R to analyze the data.

#Day 2


#Day 3
* Introduction to DNA and RNA sequencing
* [Assembling genome sequences](#assembling-genome-sequences)


##Assembling genome sequences
You will be using data from a high-throughput DNA sequencing technology (Illumina MiSeq) to assemble the chloroplast genome of the plant *Setaria viridis*. The read data has been pre-processed to contain reads likely to be from the chloroplast genome (only about 120 kb). You will use the Velvet genome assembly program, and as a group we will try different Kmer length settings to identify the best assembly by compiling and comparing some of the basic assembly statistics.

###Log in to the Danforth Center Bioinformatics infrastructure
You will use the Secure Shell (ssh) program to remotely log into the Danforth Center Bioinformatics servers from your Raspberry Pi computers.

Step 1: Launch LXTerminal
Step 2: Use ssh to log into the log-in server

 - Below the server name, user name and password are not included for security but these will be provided in class.
 - If you are asked about the RSA key fingerprint – enter yes.
 - Enter your password at the prompt.

```
ssh username@hostname.ddpsc.org
```

Setp 3: Log into one of the computing servers

- Server names will be provided at the workshop.
- If you are asked about the RSA key fingerprint – enter yes.
- Enter your password at the prompt.

```
ssh hostname
```

Like your Raspberry Pi, this is a Linux operating system (CentOS instead of Raspbian). Most of the commands you used on [Day 1](day-1) will work here, except for startx.

Let's check where we are:

```
pwd

ls -l
```

You are all logged in as the same user with the same home directory, so make your own folder to keep your work separate:

```
mkdir <yourname>

# where <yourname> = your name without spaces
```

###Working with big data files
You will use output from an Illumina MiSeq sequencer to assemble the *Setaria viridis* chloroplast genome. DNA sequence data output from Illumina and other sequencer instraments is commonly in FASTQ format. The files output from these kind of sequencing platforms can be very large (10s of gigabytes). Opening huge files can make your system unresponsive, so instead you can use a few Linux commands to get a look at these files.

First move to the directory containing the FASTQ files:

```
cd /home/csiw/miseq_data
```

Look at the first ten lines of one of the files (e.g. sviridis_1000_paired_shuffled.fastq):

```
head sviridis_1000_paired_shuffled.fastq
```

Look at the last ten lines:

```
tail sviridis_1000_paired_shuffled.fastq
```

Scroll through the file one line or page at a time:

```
less sviridis_1000_paired_shuffled.fastq

# type q to exit
```

### Using velvet – a de Bruijn graph based genome assembler
Keep in mind – for more info – the Velvet site is [here](http://www.ebi.ac.uk/~zerbino/velvet/). And the Velvet manual is [here](http://www.ebi.ac.uk/~zerbino/velvet/Manual.pdf).Velvet is run from the command line in two steps: **velveth** and **velvetg**.**velveth** collects the input read data and puts it in proper data structures for **velvetg**.**velvetg** builds the de Bruijn graph and processes it to generate an assembly.Each of you will run **velveth** and **velvetg** with a different kmer setting so that as a group we can identify the best assembly. When running, velvet will output text to the screen that tells you where it is in the assembly process.Before you start assembling the data make sure you are in your working directory. From wherever you are you can do that by typing:```cd /home/csiw/yourname/

# where yourname is the directory name you provided above
```

Each of you will be assigned a Kmer and will need to adjust the commands below to match your Kmer. Kmers should range from 17 to 149 (only use odd numbers) in increments of 2 (e.g. 17, 19, 21, and so on)

#### Running velveth
```
velveth sviridis_chloroplast 39 -fastq \
-shortPaired /home/csiw/miseq_data/sviridis_180_paired_shuffled.fastq \
-shortPaired2 /home/csiw/miseq_data/sviridis_500_paired_shuffled.fastq \
-shortPaired3 /home/csiw/miseq_data/sviridis_1000_paired_shuffled.fastq
```

#### Running velvetg
```
velvetg sviridis_chloroplast -cov_cutoff auto -ins_length 180 \
-ins_length2 500 -ins_length3 1000 -min_contig_lgth 152 -exp_cov auto  
```

When velvet completes it will provide some basic assembly statistics to the screen at the end of its output. For example:```[40.587843] Estimated Coverage = 439.325700[40.587893] Estimated Coverage cutoff = 219.662850Final graph has 55 nodes and n50 of 1744, max 14933,
total 76437, using 1261095/1546056 reads```
Please record the following:- Kmer used- Estimated coverage- Number of “nodes” (i.e. contigs)- N50- Max contig length- Total contig length- % of input reads assembled (i.e. 1261095/1546056 = 81.6%) 

Your assembly is found in ./sviridis_chloroplast/contigs.fa



